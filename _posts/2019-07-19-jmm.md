---
layout: post
title: JAVA内存模型
date: 2019-07-19
author: Nicholas Huang
header-img:
categories: JAVA
tags:
    - JAVA
---
# JAVA内存模型
## 需求
屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果
## 目标
定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
此处的变量与Java编程中的变量不同，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数。
## 规范/规定
一个线程如何和何时可以看到有其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量

    1.所有变量都存储在主内存中
    2.每个线程的工作内存保存使用到的变量的主内存副本拷贝，线程对变量的操作都在工作内存中，不能直接读写主内存中的变量
    3.线程间变量值的传递均需要通过主内存来完成
    
内存间交互操作

    操作|主内存|工作内存
    ---|-----|------
    lock|√|
    unlock|√|
    read|√|
    load||√
    use||√
    assign||√
    store||√
    write|√|
    
几点注意：
    
    1.read和load必须有序的配对出现，store和write同理。这两对中间可以插入其他操作
    2.assign和store/write对是互为充分必要条件
    3.新的变量必须在主内存中诞生，即use或者store之前必须有assign或者load
    4.lock和unlock次数匹配，一个变量在同一时刻只能被一个线程lock1到n次
    5.lock会清空工作内存中被lock变量的值，unlock会将工作内存中被unlock变量的值同步回主内存
## 一些概念
**工作内存**是cpu的寄存器（register)和高速缓存（Lx cache）的抽象描述
## 划分
线程栈 每个线程拥有自己的本地（局部）变量，线程之间传递原始类型（局部）变量的拷贝而不是变量自身
堆    Java中创建的所有对象都在堆上  
## 特征
 
 特征|volatile|synchronized|final
 ---|--------|------------|----
 可见性|√|√|√
 有序性|√|√|
 原子性||√|
 
 volatile不能保证并发下的安全，因为它不具备原子性。这个很好理解，两个线程对同一个堆上的变量进行加操作，A在本地的副本中将变量设为20，但是B本地的副本之前已经设为30了，由于可见性，会吧后发生的A的操作刷新到主内存中和B的工作内存中，导致出现问题。
 禁止重排序，是通过内存屏蔽（Memory Barrier/Memory Fence）来实现。
 **happens-before原则**也是保证有序性，时间先后顺序与先行发生原则无关




