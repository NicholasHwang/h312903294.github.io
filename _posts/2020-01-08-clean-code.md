---
layout: post
title: 《Clean Code》读书心得
date: 2020-01-08
author: Nicholas Huang
header-img:
categories: ReadingNote 
tags:
    - ReadingNote
---
# 《Clean Code》读书心得
## 回味
当我合上书后，我不太记得太多东西了。还比较能回味起来的是，Marting为了做Refactor，坚持小步快跑，每次都走TDD，保证了Refactor的质量。
其实，书中很多处于改善代码目的的要求，在平时工作中也是接触到了的，也是尽量在坚持的。比如，命名要有意义，注释要精简，函数作用要符合其命名，函数大小，类的SRP、OC，接口类中一般不声明成员变量等。
这次读《Clean Code》刚好和我走读Flutter代码有一定的重叠，我从Flutter代码中，也感受到了Google的一些要求，比如命名自解释，重要逻辑有注释等。
## 重要章节
###第2章 有意义的命名
从该章的名字就能猜出来内容是什么。只是Marting大神讲的更细一些，比如他还提出命名要比较好搜索。简单总结下命名的规则：

    1、命名要有意义，对应于书中的内容标题就是“名副其实”，“避免误导”，“做有意义的区分”。
    2、命名要规范，对应于书中的内容标题就是“使用读得出来的名称”，“使用可搜索的名称”，“避免使用编码”——这个主要是指不要在命名中带数据类型（比如int，double等），不要使用前缀（比如“m_”等），“避免思维映射”，“别扮可爱”——不要用俗语或者俚语。
    3、类和方法的命名规则，类是大驼峰名词，方法是小驼峰动词+名词。
    4、命名的规则，“每个概念对应一个词”，“别用双关语”，“使用解决方案领域名称”，“使用源自所涉问题领域的名称”，“添加有意义的语境”——这个主要是针对用于同一个实例的不同变量（比如一个邮政地址的组成，包括名字、街道、门牌号、城市、邮编等，可以将各个变量加一个统一的语境，addrName，addrStreet，addrDoorNumber，addrCity，addrZipcode），“不要添加没用的语境”。
    
###第3章 函数
这章写的大多数规则都是大多数CodeReview实践中已经遵守的了，比如：

    1、函数尽量短小（比如在xx行内）。短小带来几个好处：行为简单，易于重构，便于理解，满足SRP和OC。
    2、如果switch或者if层级过多，考虑用父类来封装共性行为，子类来封装switch和if的行为，一般考虑用工厂模式解决子类生成问题。
    3、函数参数不宜过多，超过3个，你要好好想想是否可以拆分成两个函数或者使用一个类来封装参数。这个主要是为了满足OC。
    4、将重复代码封装成函数，特别是算法那种代码，考虑策略模式。
    5、异常替换错误码这个我认为要具体情况具体分析。如果语言没有异常机制那咋办？错误码的问题其实是维护问题。常见的情况是写一个类或者枚举来做错误码，但这样的话该类或者枚举就会经常被维护。而且错误码还涉及一个设计的问题，就是按类区分，但这样容易过度设计或者设计不足。
    
###第4章 注释
这章的部分内容，我认为，在工程实践中是充满争议的。
我先表明我的观点，我个人完全认同这章的所有观点。
先说没有争议的部分：
    
    1、版权信息、修改信息、各种解释性信息（比如类、函数的非常格式化的注释，变量声明处的注释）、注释掉的代码等都应该被删除
    2、法律信息（版权声明）、重要逻辑的阐释、TODO、必要的警告等这类注释要有，且要满足简洁明了，不能啰里啰嗦。
    
现在说有争议的部分：
    
    其实就是一个注释是否一定要有的情况。可以看到上面列举的，真正和代码逻辑想的注释，只有重要逻辑才会有相应注释。Martin的观点是能用命名解决的可读性问题就用命名解决。我也同意这个观点。我任务最简洁的代码是没有代码逻辑的注释。当然，这个很难，因为涉及到复杂算法和重要逻辑的地方，你很难拒绝去给他们加注释，因为你担心别人看不懂。那么问题来了，你为什么要担心这点？是不是你代码写的还不够好，所以别人看不懂？不过，在实际的开发中，我还是会在重要的地方写注释，因为我功力还不够。
    
###第5章 格式
这章的内容，可以看做是一个怎样对代码排版的说明。Martin的意思是：

    1、局部变量尽量靠近逻辑，不要在函数一开始声明变量
    2、A函数调用B，B最好在A的后面
    
###第6章 对象和数据结构
这章的内容其实就是设计6大原则中的迪米特原则。我看了这章的感受是，要分情况。如果是模块中处于暴露给外部且和外部交互的接口或者类，那么需要考虑迪米特原则，但是，如果是模块内部的DTO，它无法使用迪米特原则，因为它设计的本意就是一堆数据的集合，这种结合是肯定设计数据的读和写的。

###第7章 错误处理
和前面第3章呼应起来了，也是强调用异常替代错误码。
异常类和包含错误码的类（为了描述简单，以下简称错误码类）在设计上相比，异常类有一个在OO上是进步的改变就是，异常类可以通过继承来解决扩展的问题，而错误码类只能通过在同一个类中修改来达到“扩展”的目的。

“别返回null值和别传递null值”，其实这两部分的内容，Martin也只是把它们提出来了，并没有给出方法来解决。这个设计防御性编程，防御性编程本来就要去做参数检查的。我个人觉得这两个观点不一定要照做。

###第8章 边界
这章主要是讲怎么使用第三方代码（库），主要是两点：

    1、边界上，使用一层来封装第三方库，比如适配器模式等，这样做的好处是能对内封闭，以防止第三方库的切换带来的震荡。
    2、使用测试，来学习使用第三方库。
    
###第9章 单元测试
因为单元测试这个东西，大家都烂熟于心，于是，我决定写点其他方面的东西。
我发现，不管公司规模，研发系统都知道单元测试的重要性，但是单元测试却又总是那个“容易受伤的男人”。我感觉，知道是一回事，做又是另一回事了。有鉴于绝大多数程序员都是男性（并没有歧视妇女同胞的意思，女性程序员我尤为尊敬！），我认为可以用网络上的一句话来概括这种现象：男人的嘴，骗人的鬼！
闲话少说，这章主要是讲TDD的。国外那帮大神级的老头似乎都特别钟爱TDD。国内真的要做TDD，我觉得还是要看领导。就像最近在看《Scrum敏捷软件开发》，该书中多次提到，敏捷转型的一个非常重要的条件是在高级管理层要有人支持。上面没人，一切白瞎！

###第10章 类
之前都是和函数相关，比函数更高一个层次的抽象是，类。
类和函数有很多相似的地方，比如短小。当然类的短小除了满足SRP，还有一个重要的作用，内聚。
根据Martin的解释，内聚是指类中的函数能够操作类中的成员变量的个数。如果类中的每个函数都能操作每个成员变量，那么该类具有最大的内聚性。
其实满足SRP的话，很容易做到高内聚。因为每个类只做一件事，那么它无法容纳和自己职责无关的行为。既然没有其他的行为，那么就不会有该行为操作的成员变量。
因此，当一个类的内聚性在丧失的时候，要考虑把这个类拆分成几个类。这样又满足了短小和SRP。当然，这样做会导致更多的类出现，更多的文件出现。不过在现代的IDE下，这都不是问题——即使用vim，也有很多将其配置成一个IDE的方法。

###第11章 系统
抽象层次继续提高。
Martin通过分开“构造”和“使用”，引出了DI，进而引出了面向切面编程。面向切面确实和模块化紧密联系，它的出现使系统层级的重构变得更简便，同时，也为测试系统提供了更为简便的方法。

###第12章 迭进
这章更像是对前面几章的一个总结。
还是从TDD开始，引入了重构，进而再次强调了函数和类的短小的重要性。

### 第13章 并发编程
这章要和附录A一起看。这章其实不是一个方法论的章节，而是一个更类似于cookbook的章节，它把并发的很多要点都提出并给出了相应的实现方法。

### 第14章 逐步改进
这章是一个cookbook的章节，用对Args类的重构，把前面几章的内容全部拉通了一遍。
个人感觉这章的出现导致12章比较鸡肋。

### 第16章 重构SerialDate
说实话，我不知道这章和14章在章节的中心思想上有什么不同。。。。。

### 第17章 味道与启发
这章是本书的浓缩，浓缩的是精华！
如果你是工作经验比较久且没有看过本书的程序员，建议你直接看这章。因为前面的章节都是为了解释为神要做么做，而这章只是告诉你应该怎么做。你都有丰富的工作经验了，开动脑筋想一想就明白了，实在想不明白在翻前面的相应内容就是了。




